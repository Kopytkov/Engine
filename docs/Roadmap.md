# Roadmap проекта: Бильярдный движок (CPU Physics + GPU Ray Marching)

Этот документ является техническим планом по миграции рендеринга на GPU с сохранением физической логики на CPU.

* **Текущий статус:** R&D (Прототипирование)
* **Главная цель:** Разделение ответственности (CPU выполняет расчеты, GPU выполняет визуализацию) и реализация игрового цикла

---

## Этап 1: Интеграция данных (CPU-GPU Bridge)

* **Приоритет:** Критический
* **Цель:** Устранить дублирование данных. Шейдер должен получать данные не из статического JSON, а из C++ объектов сцены, обновляемых в реальном времени.

### 1.1. Рефакторинг инициализации (`src/render/app_utils.cpp`)
**Задача:** Разделить функцию `SetupRaymarchBallRendering` на две логические части: инициализацию ресурсов и обновление кадра.

**Действия:**
* Удалить чтение файла `sphere.json` внутри `AppUtils`.
* Реализовать загрузку текстур и создание материалов только один раз при старте.
* Оставить в инициализации только настройку неизменяемых `uniform` констант (радиус шара, параметры света, статические материалы).

**Ожидаемый результат:** Проект компилируется. При запуске шары отображаются корректно, отсутствуют лишние операции чтения диска в каждом кадре.

### 1.2. Система передачи данных (`src/gl/gl_renderer.cpp`)
**Задача:** Реализовать метод для ежекадровой передачи позиций объектов из памяти CPU в память GPU.

**Действия:**
* Добавить метод `void UpdateUniforms(const Scene& scene, Shader& shader)` в класс рендерера.
* Реализовать итерацию по объектам сцены (`scene.GetObjects()`).
* Реализовать проверку типов (`dynamic_cast<Sphere*>`) и заполнение uniform-массива `ballPositions[i]`.
* Обеспечить передачу актуального количества объектов (`uniform int ballCount`).

**Ожидаемый результат:** Написан механизм синхронизации. Код компилируется без ошибок.

### 1.3. Интеграция в игровой цикл (`src/main.cpp`)
**Задача:** Замкнуть цикл обновления данных.

**Действия:**
* В основном цикле `while(running)` добавить вызов тестовой логики изменения координат (например, движение по синусоиде).
* Добавить вызов `renderer.UpdateUniforms(...)` перед отрисовкой кадра.
* Добавить вызов `renderer.Render(...)`.

**Ожидаемый результат:** При программном изменении координат шара в C++ (например, `sphere->SetPosition(...)`), объект мгновенно перемещается на экране.

---

## Этап 2: Физическая симуляция (Physics Engine)

* **Приоритет:** Высокий
* **Цель:** Реализовать модульное, детерминированное физическое взаимодействие объектов на основе законов классической механики.

### 2.1. Фиксированный шаг времени (`src/main.cpp`)
**Задача:** Отвязать физику от частоты кадров (FPS) для стабильности симуляции.

**Действия:**
* Реализовать паттерн "Fixed Time Step" с аккумулятором времени.
* Обеспечить вызов метода `Scene::UpdatePhysics(fixedDeltaTime)` строго фиксированное количество раз в секунду (60 Гц).

**Ожидаемый результат:** Логика обновления сцены выполняется стабильно независимо от производительности рендеринга.

### 2.2. Разделение физической и графической моделей (`Scene Component System`)
**Задача:** Устранить текущее совмещение физической и графической логики в классе `SceneObject`, чтобы обеспечить независимое развитие физики и рендеринга.

**Действия:**
* Создать новую сущность `PhysicsBody`, которая будет хранить исключительно физические свойства: позицию, скорость, ускорение, массу, флаги статики.
* Изменить `SceneObject`, оставив в нем только данные, необходимые для рендеринга (SDF-функция, материалы).
* Ввести сущность `SceneEntity` как контейнер для Body и Object.
* `PhysicsEngine` должен работать только с `PhysicsBody`.

**Ожидаемый результат:** Физическая симуляция полностью отделена от рендеринга. Появляется возможность иметь сложные графические объекты с упрощенными физическими моделями (или наоборот).

### 2.3. Универсальная система коллизий (`src/physics/physics_engine.cpp`)
**Задача:** Реализовать обнаружение и разрешение столкновений для разных типов форм.

### 2.3. Универсальная система коллизий (`src/physics/physics_engine.cpp`)
**Задача:** Реализовать обнаружение и разрешение столкновений для разных типов форм.
**Действия:**
* Реализовать методы обнаружения столкновения: `Sphere-Sphere` и `Sphere-Box`.
* Реализовать алгоритм разрешения столкновений `ResolveCollision` на основе импульсов.
* Реализовать разделение объектов (Positional Correction) для предотвращения "проваливания".
* Реализовать упругость (Restitution) для отскока.

**Ожидаемый результат:** Корректное взаимодействие динамических шаров друг с другом и со статическими препятствиями (бортами).

### 2.4. Законы Ньютона и Стабилизация (`src/physics/physics_body.cpp`)
**Задача:** Реализовать гравитацию, покой и интеграцию сил.

**Действия:**
* Внедрить гравитацию (`F = mg`) для динамических тел.
* Реализовать поддержку статических тел (масса <= 0 или -1), которые не подвержены гравитации.
* Реализовать механизм гашение упругости при малых скоростях (Resting Contact), чтобы объекты могли лежать на столе без дрожания.

**Ожидаемый результат:** Шары падают на стол, останавливаются и ведут себя естественно.

### 2.5. Модель Трения и Вращения (`Friction & Torque`)
**Задача:** Перейти от скольжения к качению.

**Действия:**
* Добавить в `PhysicsBody` параметры ориентации и угловой скорости.
* Реализовать модель Кулонова трения (Static & Dynamic Friction) в `ResolveCollision`.
* Преобразовывать силу трения во вращающий момент (Torque).

**Ожидаемый результат:** Шары при ударе приобретают вращение, могут останавливаться за счет трения, реализованы подкрутки (винты).

---

## Этап 3: Рефакторинг и архитектура

* **Приоритет:** Средний
* **Цель:** Упрощение поддержки кода, устранение сильной связности и оптимизация работы с типами.

### 3.1. Оптимизация диспетчеризации типов (Double Dispatch)

**Задача:** Избавиться от использования RTTI (`dynamic_cast`) в `PhysicsEngine` при определении пар столкновений, переложив ответственность за выбор алгоритма на геометрические классы.

**Действия:**
* В базовый класс `SceneObject` добавить чисто виртуальный метод `ComputeCollision(SceneObject* other, PhysicsBody* myBody, PhysicsBody* otherBody)`.
* В базовый класс `SceneObject` добавить виртуальные методы двойной диспетчеризации: `ComputeCollisionWith(Sphere* sphere, ...)` и `ComputeCollisionWith(Box* box, ...)`.
* Реализовать механизм Double Dispatch в классах `Sphere` и `Box`: метод `ComputeCollision` должен вызывать `other->ComputeCollisionWith(this)`.
* Перенести функции детекции (`DetectCollisionSphereSphere` и др.) из `PhysicsEngine` внутрь соответствующих методов классов `Sphere` и `Box`.
* В `PhysicsEngine` заменить цепочку `dynamic_cast` на единый полиморфный вызов `objA->ComputeCollision(objB, ...)`.

**Ожидаемый результат:** Устранение накладных расходов на `dynamic_cast`. Архитектура позволяет добавлять новые типы форм (например, Cylinder) без изменения кода физического движка.

### 3.2. Подсистема ввода (`src/input/input_controller.h`)
**Задача:** Изолировать обработку событий SDL.

**Действия:**
* Создать класс `InputController`.
* Реализовать методы опроса состояния клавиш и мыши.
* Удалить прямые обращения к `SDL_GetKeyboardState` из `main.cpp`.

**Ожидаемый результат:** Чистый `main.cpp`, управление камерой вынесено в отдельный модуль.

### 3.3. Класс приложения (`src/core/application.h`)
**Задача:** Инкапсулировать жизненный цикл приложения.

**Действия:**
* Создать класс `Application` с методами `Run()`, `Update()`, `Render()`.
* Перенести инициализацию SDL/OpenGL внутрь конструктора или метода `Init`.

**Ожидаемый результат:** Файл `main.cpp` сокращен до создания экземпляра `Application` и запуска.

### 3.4. Конвертер материалов (`src/render/material_converter.h`)
**Задача:** Автоматизировать передачу структур материалов в шейдер.

**Действия:**
* Написать конвертер `MaterialPBR (C++) -> GPU Struct`.
* Реализовать автоматическое назначение текстурных юнитов.

**Ожидаемый результат:** Добавление новых материалов не требует ручного редактирования кода рендеринга.

---

## Этап 4: Графические улучшения

* **Приоритет:** Низкий
* **Цель:** Повышение качества изображения и производительности.

### 4.1. Uniform Buffer Objects (UBO)
**Задача:** Оптимизация передачи больших объемов данных.

**Действия:**
* Определить структуру данных с выравниванием `std140`.
* Заменить массив `uniform` на `layout(std140) uniform Block { ... }`.
* Использовать `glBufferSubData` для обновления.

**Ожидаемый результат:** Возможность рендеринга сотен объектов без существенного падения производительности CPU. Также это позволит динамически менять размеры стола в шейдере.

### 4.2. Сглаживание (Anti-Aliasing)
**Задача:** Устранение алиасинга (ступенчатости) краев.

**Действия:**
* Реализовать FXAA (Fast Approximate Anti-Aliasing) в качестве пост-процесс шейдера.
* Альтернативно: Реализовать суперсэмплинг (несколько лучей на пиксель).

**Ожидаемый результат:** Гладкие края объектов, отсутствие визуального шума на границах.

---

## Этап 5: Игровая логика

* **Приоритет:** Средний
* **Цель:** Реализация правил игры и взаимодействия игрока с миром.

### 5.1. Механика кия
**Задача:** Реализовать управление ударом.

**Действия:**
* Создать сущность `Cue` (Кий).
* Реализовать вращение кия вокруг битка на основе ввода мыши.
* Реализовать метод `AddForce` или `ApplyImpulse` в `PhysicsBody`.
* Передавать импульс битку при ударе.

**Ожидаемый результат:** Возможность прицеливания и нанесения удара по шару.

### 5.2. Правила и лузы
**Задача:** Обработка попадания шаров в лузы.

**Действия:**
* Добавить SDF-примитивы для луз (вычитание геометрии) в шейдер. Используем `CSG` (Constructive Solid Geometry) для вычитания цилиндров из стола.
* Добавить триггеры (зоны без коллизии, но с событием) в `PhysicsEngine` для углов стола.
* Реализовать логику: если шар в триггере -> удаление из симуляции.
* Реализовать подсчет очков.

**Ожидаемый результат:** Полноценный игровой цикл: удар -> забитый шар -> начисление очков.

---

## Этап 6: Аудио-визуальное погружение и Инструментарий

* **Приоритет:** Будущее
* **Цель:** Превращение физической симуляции в полноценный интерактивный продукт с обратной связью.

### 6.1. Интеграция звуковой подсистемы (`Audio Engine`)
**Задача:** Реализовать динамическое озвучивание коллизий для усиления физического восприятия.

**Действия:**
* Интегрировать легковесную аудио-библиотеку (например, `SoLoud` или `Miniaudio`).
* В `PhysicsEngine::ResolveCollision` рассчитывать магнитуду импульса удара.
* Воспроизводить аудиофайл удара, модулируя громкость (Volume) и высоту тона (Pitch) в зависимости от силы столкновения.

**Ожидаемый результат:** Реалистичное звуковое сопровождение взаимодействий, аудио-отклик соответствует силе физического контакта.

### 6.2. Пользовательский интерфейс (`Debug & Game UI`)
**Задача:** Создать инструменты для настройки игры и физики в реальном времени.

**Действия:**
* Интегрировать библиотеку **Dear ImGui**.
* Создать панель отладки `Physics Tweaker`: ползунки для настройки гравитации, трения, упругости без перезапуска.
* Создать игровой HUD: отображение счета, силы удара, текущего игрока.

**Ожидаемый результат:** Удобный инструмент для геймдизайна и визуализации состояния игры.

### 6.3. AI-Соперник (`Bot Logic`)
**Задача:** Реализовать возможность одиночной игры против компьютера.

**Действия:**
* Реализовать "Виртуальную симуляцию": возможность скопировать состояние физического мира и быстро просчитать исход удара без рендеринга.
* Написать алгоритм бота, который перебирает варианты ударов (угол, сила) и выбирает тот, который максимизирует вероятность забитого шара (Score Maximization).

**Ожидаемый результат:** PvE режим, где компьютер может составить конкуренцию игроку.