# Roadmap проекта: Бильярдный движок (CPU Physics + GPU Ray Marching)

Этот документ является техническим планом по миграции рендеринга на GPU с сохранением физической логики на CPU.

* **Текущий статус:** R&D (Прототипирование)
* **Главная цель:** Разделение ответственности (CPU выполняет расчеты, GPU выполняет визуализацию) и реализация игрового цикла

---

## Этап 1: Интеграция данных (CPU-GPU Bridge)

* **Приоритет:** Критический
* **Цель:** Устранить дублирование данных. Шейдер должен получать данные не из статического JSON, а из C++ объектов сцены, обновляемых в реальном времени.

### 1.1. Рефакторинг инициализации (`src/render/app_utils.cpp`)
**Задача:** Разделить функцию `SetupRaymarchBallRendering` на две логические части: инициализацию ресурсов и обновление кадра.

**Действия:**
* Удалить чтение файла `sphere.json` внутри `AppUtils`.
* Реализовать загрузку текстур и создание материалов только один раз при старте.
* Оставить в инициализации только настройку неизменяемых `uniform` констант (радиус шара, параметры света, статические материалы).

**Ожидаемый результат:** Проект компилируется. При запуске шары отображаются корректно, отсутствуют лишние операции чтения диска в каждом кадре.

### 1.2. Система передачи данных (`src/gl/gl_renderer.cpp`)
**Задача:** Реализовать метод для ежекадровой передачи позиций объектов из памяти CPU в память GPU.

**Действия:**
* Добавить метод `void UpdateUniforms(const Scene& scene, Shader& shader)` в класс рендерера.
* Реализовать итерацию по объектам сцены (`scene.GetObjects()`).
* Реализовать проверку типов (`dynamic_cast<Sphere*>`) и заполнение uniform-массива `ballPositions[i]`.
* Обеспечить передачу актуального количества объектов (`uniform int ballCount`).

**Ожидаемый результат:** Написан механизм синхронизации. Код компилируется без ошибок.

### 1.3. Интеграция в игровой цикл (`src/main.cpp`)
**Задача:** Замкнуть цикл обновления данных.

**Действия:**
* В основном цикле `while(running)` добавить вызов тестовой логики изменения координат (например, движение по синусоиде).
* Добавить вызов `renderer.UpdateUniforms(...)` перед отрисовкой кадра.
* Добавить вызов `renderer.Render(...)`.

**Ожидаемый результат:** При программном изменении координат шара в C++ (например, `sphere->SetPosition(...)`), объект мгновенно перемещается на экране.

---

## Этап 2: Физическая симуляция (Physics Engine)

* **Приоритет:** Высокий
* **Цель:** Реализовать детерминированное физическое взаимодействие объектов.

### 2.1. Фиксированный шаг времени (`src/main.cpp`)
**Задача:** Отвязать физику от частоты кадров (FPS) для стабильности симуляции.

**Действия:**
* Реализовать паттерн "Fixed Time Step" с аккумулятором времени.
* Обеспечить вызов метода `Scene::Update(fixedDeltaTime)` строго фиксированное количество раз в секунду (например, 60 или 120 Гц).

**Ожидаемый результат:** Логика обновления сцены выполняется стабильно независимо от производительности рендеринга.

### 2.2. Столкновения Шар-Шар (`src/scene/physics_engine.cpp`)
**Задача:** Реализовать упругое соударение сферических объектов.

**Действия:**
* Создать класс `PhysicsEngine`.
* Реализовать алгоритм обнаружения коллизий: `distance(posA, posB) < radiusA + radiusB`.
* Реализовать разрешение коллизий: обмен импульсами с сохранением энергии и импульса системы.

**Ожидаемый результат:** При движении шаров навстречу друг другу происходит реалистичный отскок, объекты не проходят сквозь друг друга.

### 2.3. Столкновения Шар-Стол (`src/scene/scene.cpp`)
**Задача:** Ограничить рабочую область симуляции.

**Действия:**
* Определить границы стола через AABB (Axis Aligned Bounding Box).
* Реализовать инверсию вектора скорости при достижении границ.
* Реализовать выталкивание шара, если он случайно оказался внутри борта.

**Ожидаемый результат:** Шары удерживаются в пределах игрового поля.

### 2.4. Трение и затухание (`src/scene/scene_object.cpp`)
**Задача:** Реализовать потерю энергии при движении.

**Действия:**
* Добавить векторы `velocity` (скорость) и `acceleration` (ускорение) в базовый класс объекта.
* Реализовать применение силы трения: `velocity *= (1.0 - friction * dt)`.

**Ожидаемый результат:** Шары плавно замедляются и останавливаются после удара.

---

## Этап 3: Рефакторинг и архитектура

* **Приоритет:** Средний
* **Цель:** Упрощение поддержки кода и устранение сильной связности в `main.cpp`.

### 3.1. Подсистема ввода (`src/input/input_controller.h`)
**Задача:** Изолировать обработку событий SDL.

**Действия:**
* Создать класс `InputController`.
* Реализовать методы опроса состояния клавиш и мыши.
* Удалить прямые обращения к `SDL_GetKeyboardState` из `main.cpp`.

**Ожидаемый результат:** Чистый `main.cpp`, управление камерой вынесено в отдельный модуль.

### 3.2. Класс приложения (`src/core/application.h`)
**Задача:** Инкапсулировать жизненный цикл приложения.

**Действия:**
* Создать класс `Application` с методами `Run()`, `Update()`, `Render()`.
* Перенести инициализацию SDL/OpenGL внутрь конструктора или метода `Init`.

**Ожидаемый результат:** Файл `main.cpp` сокращен до создания экземпляра `Application` и запуска.

### 3.3. Конвертер материалов (`src/render/material_converter.h`)
**Задача:** Автоматизировать передачу структур материалов в шейдер.

**Действия:**
* Написать конвертер `MaterialPBR (C++) -> GPU Struct`.
* Реализовать автоматическое назначение текстурных юнитов.

**Ожидаемый результат:** Добавление новых материалов не требует ручного редактирования кода рендеринга.

---

## Этап 4: Графические улучшения

* **Приоритет:** Низкий
* **Цель:** Повышение качества изображения и производительности.

### 4.1. Uniform Buffer Objects (UBO)
**Задача:** Оптимизация передачи больших объемов данных.

**Действия:**
* Определить структуру данных с выравниванием `std140`.
* Заменить массив `uniform` на `layout(std140) uniform Block { ... }`.
* Использовать `glBufferSubData` для обновления.

**Ожидаемый результат:** Возможность рендеринга сотен объектов без существенного падения производительности CPU.

### 4.2. Сглаживание (Anti-Aliasing)
**Задача:** Устранение алиасинга (ступенчатости) краев.

**Действия:**
* Реализовать FXAA (Fast Approximate Anti-Aliasing) в качестве пост-процесс шейдера.
* Альтернативно: Реализовать суперсэмплинг (несколько лучей на пиксель).

**Ожидаемый результат:** Гладкие края объектов, отсутствие визуального шума на границах.

---

## Этап 5: Игровая логика

* **Приоритет:** Средний
* **Цель:** Реализация правил игры и взаимодействия игрока с миром.

### 5.1. Механика кия
**Задача:** Реализовать управление ударом.

**Действия:**
* Создать сущность `Cue` (Кий).
* Реализовать вращение кия вокруг битка на основе ввода мыши.
* Реализовать накопление силы удара и передачу импульса битку.

**Ожидаемый результат:** Возможность прицеливания и нанесения удара по шару.

### 5.2. Правила и лузы
**Задача:** Обработка попадания шаров в лузы.

**Действия:**
* Добавить SDF-примитивы для луз (вычитание геометрии).
* Реализовать триггер: если шар в лузе -> удаление из симуляции.
* Реализовать подсчет очков.

**Ожидаемый результат:** Полноценный игровой цикл: удар -> забитый шар -> начисление очков.