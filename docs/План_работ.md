# Подробный план разработки игрового движка (12 недель)

## Общие принципы

- **Команда**: 4 человека (Участник 1: Сцена и алгоритмы; Участник 2: Рендеринг и текстурирование; Участник 3: Материалы и освещение; Участник 4: JSON и объекты).
- **Гибкость**: Каждая задача самодостаточна — используйте заглушки (например, фиксированные значения вместо реальных объектов) для независимой работы. Если задача не выполнена, в следующих неделях используйте простые альтернативы (например, хардкод вместо JSON).
- **Документация**: Еженедельно добавляйте в общий README.md: описание класса/функции (вход/выход), код-сниппеты, тесты, ссылки. Используйте Doxygen (как вариант) для автогенерации.
- **Контрольные точки**: Недели 4, 8, 12 — merge в main, запуск тестов, обсуждение (30 минут).
- **Технологии**:
  - C++17.
  - Библиотеки: nlohmann/json (GitHub: https://github.com/nlohmann/json), GLM (https://github.com/g-truc/glm), SDL2 + OpenGL (https://www.libsdl.org/, https://learnopengl.com/).
  - Структура проекта: src/ (код), include/ (заголовки), assets/ (текстуры/JSON), docs/ (документация), tests/ (юнит-тесты с Google Test).
- **Тестирование**: Каждый модуль — отдельный тест (например, `test_scene.cpp`). Запуск: `make test`.
- **Репозиторий**: GitHub, ветки: `feature/scene-aabb`, `feature/render-cube`. PR еженедельно.

## Еженедельный план

### Неделя 1: Подготовка и исследование

- **Участник 1 (Сцена)**:
  - Изучить AABB: прочитать https://en.wikipedia.org/wiki/Minimum_bounding_box и https://learnopengl.com/Guest-Articles/2020/Spatial-Indexing. Написать в docs/algorithms.md: описание (AABB — bounding box для пересечения лучей; плюсы: простота, O(1) проверка; минусы: неэффективно для sparse сцен), код-пример проверки пересечения (функция `bool intersects(AABB& other)`), ссылки.
  - Изучить octree: https://en.wikipedia.org/wiki/Octree и GitHub: https://github.com/jrouwe/Octree. Добавить в algorithms.md: описание (дерево для 3D-разбиения; плюсы: логарифмическая сложность; минусы: overhead на малых сценах), псевдокод вставки узла.
  - Тест: Скомпилировать пример из OpenGL tutorial, убедиться, что проект собирается (`cmake . && make`).
- **Участник 2 (Рендеринг)**:
  - Настроить проект: CMakeLists.txt с SDL2, OpenGL, GLM. Код: в src/main.cpp — инициализация SDL окна (800x600), цикл рендеринга с glClear(GL_COLOR_BUFFER_BIT).
  - Добавить базовый шейдер: vertex.glsl (pass-through позиции), fragment.glsl (solid color). Загрузка с помощью glad (https://github.com/Dav1dde/glad).
  - Тест: Окно открывается, рендерится синий экран. Коммит: `git commit -m "Init SDL/OpenGL project"`.
- **Участник 3 (Материалы/Освещение)**:
  - Изучить Phong: https://learnopengl.com/Lighting/Basic-Lighting. Определить Material: struct с vec3 ambient, diffuse, specular; float shininess.
  - Код: В src/material.h — класс Material с getters/setters. Тест: В main.cpp — создать Material, вывести параметры в консоль (std::cout).
  - Изучить Lambert: упрощённый diffuse без specular. Добавить в docs/lighting.md: сравнение (Phong — реалистичные блики; Lambert — матовый).
- **Участник 4 (JSON/Объекты)**:
  - Установить nlohmann/json: добавить в CMakeLists.txt (fetchcontent). Пример JSON: assets/object.json — `{"name": "cube", "position": \[0,0,0\], "scale": \[1,1,1\], "texture": "cube.png"}`.
  - Код: src/json_parser.cpp — функция `Object parseObject(const std::string& file)`. `Struct Object { std::string name; glm::vec3 pos; }`.
  - Тест: Загрузить JSON, вывести pos в консоль. Документация: docs/json.md — схема JSON, примеры.
- **Документация**: Каждый — 1 страница (условно одна) в docs/ (Markdown). Общий: Установка зависимостей (vcpkg или conan для SDL/GLM).

### Неделя 2: Базовые компоненты

- **Участник 1**:
  - Класс Scene: include/scene.h — `vector&lt;Object\*&gt; objects; void add(Object\* obj); void update()`.
  - Тест: В tests/scene_test.cpp — создать Scene, добавить куб `(Object с AABB \[ -0.5,-0.5,-0.5 \] to \[0.5,0.5,0.5\] )`, вызвать `update(), assert(objects.size() == 1)`.
- **Участник 2**:
  - Рендеринг куба: Генерация вершин (24 вершины, 36 индекса для куба). VAO/VBO: glGenBuffers, glBufferData.
  - Текстура-заглушка: 1x1 пиксель `(unsigned char data\[3\] = {255,0,0}; glTexImage2D)`.
  - Тест: Куб рендерится красным в центре экрана. Шейдер: `uniform mat4 MVP; gl_Position = MVP \* vec4(position,1.0)`.
- **Участник 3**:
  - Применить Material: В fragment.glsl — `uniform vec3 diffuse; fragColor = vec4(diffuse,1.0)`.
  - Код: src/renderer.cpp — `void setMaterial(Material& mat) { glUniform3fv(...); }`.
  - Тест: Куб с diffuse {1,0,0} — красный; с {0,1,0} — зелёный.
- **Участник 4**:
  - Парсер: Расширить parseObject для Material (добавить в JSON `"material": {"diffuse": \[1,0,0\]}`).
  - Тест: Загрузить куб из JSON, создать `Object `с pos и material, вывести в консоль.
- **Документация**: Описать классы (`Scene: manages objects; Renderer: handles GL calls`). Добавить UML-диаграммы (plantuml).

### Неделя 3: Расширение функционала

- **Участник 1**:
  - AABB в Scene: Каждый Object имеет AABB. Функция `bool isVisible(glm::vec3 cameraPos) — if (distance(camera, AABB.center) &gt; AABB.radius) return false`.
  - Тест: 2 куба, один близко — visible, другой далеко (`dist&gt;10`) — не visible.
- **Участник 2**:
  - Текстурирование: Загрузка PNG с stb_image (https://github.com/nothings/stb). glBindTexture, sampler2D в шейдере.
  - Тест: Куб с шахматной текстурой (сгенерировать простую в коде или скачать).
- **Участник 3**:
  - Источник света: `Struct Light { glm::vec3 pos; vec3 color; };` uniform в шейдере. Phong: `ambient + diffuse \* dot(normal, lightDir)`.
  - Тест: Куб освещается белым светом из (0,0,5), тёмный без света.
- **Участник 4**:
  - Динамическое обновление: Функция `void reloadScene(const std::string& file) { clear objects; parse new; }`.
  - Тест: Изменить JSON pos, нажать 'R' в main loop — перезагрузка, куб сдвинулся.
- **Документация**: AABB код + формулы; шейдеры (full GLSL); JSON схема (JSON Schema draft).

### Неделя 4: Первая интеграция

- **Все**:
  - Merge: В main.cpp — `Scene scene; parse JSON -&gt; add to scene; for each visible obj: renderer.draw(obj, light, material)`.
  - Тест: Куб из JSON, с текстурой, материалом, светом — рендерится, 'R' обновляет.
  - Заглушки: Если нет света — fixed uniform; если нет JSON — хардкод куб.
- **Документация**: Интеграция: вызовы функций, `bottlenecks (e.g., gl calls per frame)`.

### Неделя 5: Оптимизация сцены

- **Участник 1**:
  - Octree: Класс `OctreeNode { AABB bounds; vector&lt;Object\*&gt; objects; OctreeNode\* children\[8\]; }; insert(Object\*), queryVisible(AABB frustum)`.
  - Сравнение: Тест на 10 кубов — время `update()` для AABB vs Octree (`std::chrono`).
- **Участник 2**:
  - Буферизация: Один VBO для всех объектов (instanced rendering? Или batch).
  - Тест: 10 кубов рендерятся без лагов (FPS &gt;30).
- **Участник 3**:
  - Направленный свет: `Struct DirLight { vec3 dir; vec3 color; }`; В шейдере: dot(normal, -dir).
  - Тест: Солнечный свет сверху — плоскость освещена снизу тёмная.
- **Участник 4**:
  - JSON для света: `{"lights": \[{"type":"point", "pos":\[0,0,5\], "color":\[1,1,1\]}\]}`.
  - Тест: Загрузить 2 света, применить.
- **Документация**: Таблица сравнения AABB/Octree (столбцы: сцена размер, время query, память).

### Неделя 6: Динамика

- **Участник 1**:

- Динамика: `Scene::update(float dt) — for obj: obj-&gt;pos += velocity \* dt; rebuild AABB`.
- Тест: Камера `(glm::mat4 view = glm::lookAt(pos, target, up))` движется WASD.
- **Участник 2**:
  - Матрицы: В рендеринге `MVP = proj \* view \* model;` `GLM: glm::perspective, glm::translate`.
  - Тест: Куб следует за камерой (не рендерится сзади).
- **Участник 3**:
  - Мерцание: `Light::intensity = base + sin(time)\*amp;` В update().
  - Тест: Костёр — свет мигает, куб краснеет/бледнеет.
- **Участник 4**:
  - JSON анимация: `"animation": {"velocity": \[1,0,0\]}`.
  - Тест: Объект движется вправо после reload.
- **Документация**: Матрицы GLM примеры; анимация формулы.

### Неделя 7: Сложные сцены

- **Участник 1**:
  - Сцена: Генерация ландшафта (grid 10x10 плоскостей), дом (6 кубов). Insert в octree.
  - Тест: Query visible — только 5 объектов в фрустуме.
- **Участник 2**:
  - Текстуры: Трава для ландшафта (скачать free PNG), дерево для дома.
  - Тест: Ландшафт зелёный, дом коричневый.
- **Участник 3**:
  - Тени: Shadow mapping — depth FBO, bias в шейдере.
  - Тест: Куб отбрасывает тень на плоскость от point light.
- **Участник 4**:
  - JSON сцена: `{"scene": {"objects": \[cube1, plane_grid\], "lights": \[...\]}}`.
  - Тест: Загрузить полную сцену.
- **Документация**: Генерация meshes (код для grid).

### Неделя 8: Вторая интеграция

- **Все**:
  - Полная сцена: Ландшафт + дом + костёр (мерцающий свет внутри), тени.
  - Тест: Камера летает (mouse look), FPS &gt;20.
  - Заглушки: Без теней — no-shadow шейдер.
- **Документация**: Производительность (gprof профилинг), screenshots.

### Неделя 9: Оптимизация рендеринга

- **Участник 1**:
  - Оптимизация: `Lazy rebuild octree (if moved &gt; threshold)`.
  - Тест: 50 кубов (random pos), query &lt;1ms.
- **Участник 2**:
  - VBO/VAO: Static draw для статичных, dynamic для анимированных.
  - Тест: Batch render — glDrawArraysInstanced для 10 кубов.
- **Участник 3**:
  - Оптимизация света: Max 4 lights в шейдере, else approximate.
  - Тест: 2 point + 1 dir — сцена освещена.
- **Участник 4**:
  - Анимация JSON: `"keyframes": \[{"time":0, "pos":\[0,0,0\]}, {"time":1, "pos":\[5,0,0\]}\]`.
  - Тест: Линейная интерполяция.
- **Документация**: Оптимизации (before/after FPS).

### Неделя 10: Тестирование и улучшения

- **Участник 1**:
  - Тест AABB vs Octree: Скрипт gen_scene(100 objs), measure query time.
  - Выбор: Octree если &gt;20 objs, else AABB.
- **Участник 2**:
  - Пост-обработка: FBO для fog — `fragColor = mix(fogColor, color, exp(-dist))`.
  - Тест: Дальний ландшафт в тумане.
- **Участник 3**:
  - Spotlight: `Struct SpotLight {vec3 dir, cutoff cos}; attenuation`.
  - Тест: Фонарь на дом — освещает только фасад.
- **Участник 4**:
  - Валидация: `nlohmann::json::parse` с `schema check (if !valid, log error)`.
  - Тест: Некорректный JSON — console error, fallback to default.
- **Документация**: Таблица тестов (pass/fail, coverage &gt;80%).

### Неделя 11: Финальная доработка

- **Участник 1**:
  - Баги: Fix memory leaks (valgrind), stable с 100 objs.
  - Тест: Long run 10min no crash.
- **Участник 2**:
  - Нормали: В vertex data добавить normals, в шейдере для lighting.
  - Тест: Гладкое освещение на sphere (add sphere mesh).
- **Участник 3**:
  - Улучшить тени: PCF sampling для soft shadows.
  - Тест: Мягкие тени от дома.
- **Участник 4**:
  - UI: ImGui (https://github.com/ocornut/imgui) — кнопка `"Reload Scene"`.
  - Тест: Клик — перезагрузка без рестарта.
- **Документация**: Full API ref (Doxygen HTML).

### Неделя 12: Финальная интеграция и документация

- **Все**:
  - Merge all: Полный движок — сцена Minecraft (ландшафт, дом, костёр внутри с мерцанием/тенями, анимация дыма?).
  - Тест: Видео demo (record с OBS), FPS report.
- **Документация**: Отчёт (20 стр): Введение, Архитектура (диаграммы), Алгоритмы (AABB/Octree с кодом/ссылками), Материалы (Phong формулы), JSON (примеры), Оптимизации, Заключение. + User guide: как запустить, edit JSON.

## Рекомендации

- Ежедневно: 1h код, 30min докс. Если отстаёшь — приоритизируй тесты.
- Git: Squash commits, review PR.
- Ресурсы: Воровать код с GitHub (e.g., octree impl from https://github.com/mtrebi), но адаптировать и документировать.
